"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ion_js_1 = require("ion-js");
var crypto_1 = require("crypto");
var _CryptoHasher = (function () {
    function _CryptoHasher(algorithm) {
        this.algorithm = algorithm;
        this._hash = crypto_1.createHash(algorithm);
    }
    _CryptoHasher.prototype.update = function (bytes) {
        this._hash.update(bytes);
    };
    _CryptoHasher.prototype.digest = function () {
        var digest = this._hash.digest();
        this._hash = crypto_1.createHash(this.algorithm);
        return digest;
    };
    return _CryptoHasher;
}());
exports._CryptoHasher = _CryptoHasher;
var _HashReaderImpl = (function () {
    function _HashReaderImpl(_reader, _hashFunctionProvider) {
        this._reader = _reader;
        this._hashFunctionProvider = _hashFunctionProvider;
        this._ionType = null;
        this._hasher = new _Hasher(this._hashFunctionProvider);
    }
    _HashReaderImpl.prototype.annotations = function () { return this._reader.annotations(); };
    _HashReaderImpl.prototype.bigIntValue = function () { return this._reader.bigIntValue(); };
    _HashReaderImpl.prototype.booleanValue = function () { return this._reader.booleanValue(); };
    _HashReaderImpl.prototype.byteValue = function () { return this._reader.byteValue(); };
    _HashReaderImpl.prototype.decimalValue = function () { return this._reader.decimalValue(); };
    _HashReaderImpl.prototype.depth = function () { return this._reader.depth(); };
    _HashReaderImpl.prototype.fieldName = function () { return this._reader.fieldName(); };
    _HashReaderImpl.prototype.intSize = function () { return this._reader.intSize(); };
    _HashReaderImpl.prototype.isNull = function () { return this._reader.isNull(); };
    _HashReaderImpl.prototype.numberValue = function () { return this._reader.numberValue(); };
    _HashReaderImpl.prototype.stringValue = function () { return this._reader.stringValue(); };
    _HashReaderImpl.prototype.timestampValue = function () { return this._reader.timestampValue(); };
    _HashReaderImpl.prototype.type = function () { return this._reader.type(); };
    _HashReaderImpl.prototype.value = function () { return this._reader.value(); };
    _HashReaderImpl.prototype._traverse = function () {
        for (var type = void 0; type = this.next();) {
            if (type.isContainer && !this.isNull()) {
                this.stepIn();
                this._traverse();
                this.stepOut();
            }
        }
    };
    _HashReaderImpl.prototype.next = function () {
        if (this._ionType && this._ionType.isContainer) {
            if (this.isNull()) {
                this._hasher._scalar(this);
            }
            else {
                this.stepIn();
                this._traverse();
                this.stepOut();
            }
        }
        if (this._ionType && this._ionType.isScalar) {
            this._hasher._scalar(this);
        }
        this._ionType = this._reader.next();
        return this._ionType;
    };
    _HashReaderImpl.prototype.stepIn = function () {
        this._hasher._stepIn(this);
        this._reader.stepIn();
        this._ionType = null;
    };
    _HashReaderImpl.prototype.stepOut = function () {
        this._traverse();
        this._reader.stepOut();
        this._hasher._stepOut();
    };
    _HashReaderImpl.prototype.digest = function () { return this._hasher._digest(); };
    _HashReaderImpl.prototype._annotations = function () { return this.annotations(); };
    _HashReaderImpl.prototype._fieldName = function () { return this.fieldName(); };
    _HashReaderImpl.prototype._isNull = function () { return this.isNull(); };
    _HashReaderImpl.prototype._type = function () { return this._ionType; };
    _HashReaderImpl.prototype._value = function () { return this.value(); };
    return _HashReaderImpl;
}());
exports._HashReaderImpl = _HashReaderImpl;
var _HashWriterImpl = (function () {
    function _HashWriterImpl(_writer, _hashFunctionProvider) {
        this._writer = _writer;
        this._hashFunctionProvider = _hashFunctionProvider;
        this.__ionType = null;
        this.__annotations = [];
        this.__fieldName = null;
        this.__isNull = false;
        this.__value = null;
        this._hasher = new _Hasher(this._hashFunctionProvider);
    }
    _HashWriterImpl.prototype.addAnnotation = function (annotation) {
        this._writer.addAnnotation(annotation);
        this.__annotations.push(annotation);
    };
    _HashWriterImpl.prototype.setAnnotations = function (annotations) {
        this._writer.setAnnotations(annotations);
        this.__annotations = annotations;
    };
    _HashWriterImpl.prototype._hashScalar = function (type, value) {
        this.__ionType = type;
        this.__value = value;
        this.__isNull = (value == undefined || value == null);
        this._hasher._scalar(this);
        this.__fieldName = null;
        this.__annotations = [];
    };
    _HashWriterImpl.prototype.writeBlob = function (value) {
        this._hashScalar(ion_js_1.IonTypes.BLOB, value);
        this._writer.writeBlob(value);
    };
    _HashWriterImpl.prototype.writeBoolean = function (value) {
        this._hashScalar(ion_js_1.IonTypes.BOOL, value);
        this._writer.writeBoolean(value);
    };
    _HashWriterImpl.prototype.writeClob = function (value) {
        this._hashScalar(ion_js_1.IonTypes.CLOB, value);
        this._writer.writeClob(value);
    };
    _HashWriterImpl.prototype.writeDecimal = function (value) {
        this._hashScalar(ion_js_1.IonTypes.DECIMAL, value);
        this._writer.writeDecimal(value);
    };
    _HashWriterImpl.prototype.writeFloat32 = function (value) {
        this._hashScalar(ion_js_1.IonTypes.FLOAT, value);
        this._writer.writeFloat32(value);
    };
    _HashWriterImpl.prototype.writeFloat64 = function (value) {
        this._hashScalar(ion_js_1.IonTypes.FLOAT, value);
        this._writer.writeFloat64(value);
    };
    _HashWriterImpl.prototype.writeInt = function (value) {
        this._hashScalar(ion_js_1.IonTypes.INT, value);
        this._writer.writeInt(value);
    };
    _HashWriterImpl.prototype.writeNull = function (type) {
        this._hashScalar(type, null);
        this._writer.writeNull(type);
    };
    _HashWriterImpl.prototype.writeString = function (value) {
        this._hashScalar(ion_js_1.IonTypes.STRING, value);
        this._writer.writeString(value);
    };
    _HashWriterImpl.prototype.writeSymbol = function (value) {
        this._hashScalar(ion_js_1.IonTypes.SYMBOL, value);
        this._writer.writeSymbol(value);
    };
    _HashWriterImpl.prototype.writeTimestamp = function (value) {
        this._hashScalar(ion_js_1.IonTypes.TIMESTAMP, value);
        this._writer.writeTimestamp(value);
    };
    _HashWriterImpl.prototype.stepIn = function (type) {
        this.__ionType = type;
        this.__value = null;
        this.__isNull = false;
        this._hasher._stepIn(this);
        this._writer.stepIn(type);
        this.__fieldName = null;
        this.__annotations = [];
    };
    _HashWriterImpl.prototype.stepOut = function () {
        this._hasher._stepOut();
        this._writer.stepOut();
    };
    _HashWriterImpl.prototype.writeFieldName = function (fieldName) {
        this.__fieldName = fieldName;
        this._writer.writeFieldName(fieldName);
    };
    _HashWriterImpl.prototype.writeValue = function (reader) {
        this._writeValue(reader);
    };
    _HashWriterImpl.prototype._writeValue = function (reader, _depth) {
        if (_depth === void 0) { _depth = 0; }
        var type = reader.type();
        if (type === null) {
            return;
        }
        if (_depth > 0) {
            var fieldName = reader.fieldName();
            if (fieldName !== null) {
                this.writeFieldName(fieldName);
            }
        }
        this.setAnnotations(reader.annotations());
        if (reader.isNull()) {
            this.writeNull(type);
        }
        else {
            switch (type) {
                case ion_js_1.IonTypes.BOOL:
                    this.writeBoolean(reader.booleanValue());
                    break;
                case ion_js_1.IonTypes.INT:
                    this.writeInt(reader.bigIntValue());
                    break;
                case ion_js_1.IonTypes.FLOAT:
                    this.writeFloat64(reader.numberValue());
                    break;
                case ion_js_1.IonTypes.DECIMAL:
                    this.writeDecimal(reader.decimalValue());
                    break;
                case ion_js_1.IonTypes.TIMESTAMP:
                    this.writeTimestamp(reader.timestampValue());
                    break;
                case ion_js_1.IonTypes.SYMBOL:
                    this.writeSymbol(reader.stringValue());
                    break;
                case ion_js_1.IonTypes.STRING:
                    this.writeString(reader.stringValue());
                    break;
                case ion_js_1.IonTypes.CLOB:
                    this.writeClob(reader.byteValue());
                    break;
                case ion_js_1.IonTypes.BLOB:
                    this.writeBlob(reader.byteValue());
                    break;
                case ion_js_1.IonTypes.LIST:
                    this.stepIn(ion_js_1.IonTypes.LIST);
                    break;
                case ion_js_1.IonTypes.SEXP:
                    this.stepIn(ion_js_1.IonTypes.SEXP);
                    break;
                case ion_js_1.IonTypes.STRUCT:
                    this.stepIn(ion_js_1.IonTypes.STRUCT);
                    break;
                default: throw new Error('Unrecognized type ' + (type !== null ? type.name : type));
            }
            if (type.isContainer) {
                reader.stepIn();
                this._writeValues(reader, _depth + 1);
                this.stepOut();
                reader.stepOut();
            }
        }
    };
    _HashWriterImpl.prototype.writeValues = function (reader) {
        this._writeValues(reader);
    };
    _HashWriterImpl.prototype._writeValues = function (reader, _depth) {
        if (_depth === void 0) { _depth = 0; }
        var type = reader.type();
        if (type === null) {
            type = reader.next();
        }
        while (type !== null) {
            this._writeValue(reader, _depth);
            type = reader.next();
        }
    };
    _HashWriterImpl.prototype.getBytes = function () { return this._writer.getBytes(); };
    _HashWriterImpl.prototype.close = function () { };
    _HashWriterImpl.prototype.depth = function () { return this._writer.depth(); };
    _HashWriterImpl.prototype.digest = function () { return this._hasher._digest(); };
    _HashWriterImpl.prototype._annotations = function () { return this.__annotations; };
    _HashWriterImpl.prototype._fieldName = function () { return this.__fieldName; };
    _HashWriterImpl.prototype._isNull = function () { return this.__isNull; };
    _HashWriterImpl.prototype._type = function () { return this.__ionType; };
    _HashWriterImpl.prototype._value = function () { return this.__value; };
    return _HashWriterImpl;
}());
exports._HashWriterImpl = _HashWriterImpl;
var _Hasher = (function () {
    function _Hasher(_ihp) {
        this._ihp = _ihp;
        this._hasherStack = [];
        this._currentHasher = new _Serializer(this._ihp(), 0);
        this._hasherStack.push(this._currentHasher);
    }
    _Hasher.prototype._scalar = function (ionValue) {
        this._currentHasher._scalar(ionValue);
    };
    _Hasher.prototype._stepIn = function (ionValue) {
        var hf = this._currentHasher._hashFunction;
        if (this._currentHasher instanceof _StructSerializer) {
            hf = this._ihp();
        }
        if (ionValue._type() == ion_js_1.IonTypes.STRUCT) {
            this._currentHasher = new _StructSerializer(hf, this._depth(), this._ihp);
        }
        else {
            this._currentHasher = new _Serializer(hf, this._depth());
        }
        this._hasherStack.push(this._currentHasher);
        this._currentHasher._stepIn(ionValue);
    };
    _Hasher.prototype._stepOut = function () {
        if (this._depth() == 0) {
            throw new Error("_Hasher cannot stepOut any further");
        }
        this._currentHasher._stepOut();
        var poppedHasher = this._hasherStack.pop();
        this._currentHasher = this._hasherStack[this._hasherStack.length - 1];
        if (this._currentHasher instanceof _StructSerializer) {
            var digest = poppedHasher._digest();
            this._currentHasher._appendFieldHash(digest);
        }
    };
    _Hasher.prototype._digest = function () {
        if (this._depth() != 0) {
            throw new Error("A digest may only be provided at the same depth hashing started");
        }
        return this._currentHasher._digest();
    };
    _Hasher.prototype._depth = function () {
        return this._hasherStack.length - 1;
    };
    return _Hasher;
}());
var _Serializer = (function () {
    function _Serializer(_hashFunction, _depth) {
        this._hashFunction = _hashFunction;
        this._depth = _depth;
        this._hasContainerAnnotations = false;
    }
    _Serializer.prototype._handleFieldName = function (fieldName) {
        if (fieldName != undefined && this._depth > 0) {
            this._writeSymbol(fieldName);
        }
    };
    _Serializer.prototype._handleAnnotationsBegin = function (ionValue, isContainer) {
        if (isContainer === void 0) { isContainer = false; }
        var annotations = ionValue._annotations();
        if (annotations.length > 0) {
            this._beginMarker();
            this._update(_TQ_ANNOTATED_VALUE);
            for (var _i = 0, annotations_1 = annotations; _i < annotations_1.length; _i++) {
                var annotation = annotations_1[_i];
                if (annotation === '$0') {
                    throw new Error("Symbol ID '$0' is not currently supported.");
                }
                this._writeSymbol(annotation);
            }
            if (isContainer) {
                this._hasContainerAnnotations = true;
            }
        }
    };
    _Serializer.prototype._handleAnnotationsEnd = function (ionValue, isContainer) {
        if (isContainer === void 0) { isContainer = false; }
        if ((ionValue && ionValue._annotations().length > 0)
            || (isContainer && this._hasContainerAnnotations)) {
            this._endMarker();
            if (isContainer) {
                this._hasContainerAnnotations = false;
            }
        }
    };
    _Serializer.prototype._update = function (bytes) { this._hashFunction.update(bytes); };
    _Serializer.prototype._beginMarker = function () { this._hashFunction.update(_BEGIN_MARKER); };
    _Serializer.prototype._endMarker = function () { this._hashFunction.update(_END_MARKER); };
    _Serializer.prototype._writeSymbol = function (token) {
        this._beginMarker();
        var scalarBytes = this._getBytes(ion_js_1.IonTypes.SYMBOL, token, false);
        var _a = this._scalarOrNullSplitParts(ion_js_1.IonTypes.SYMBOL, false, scalarBytes), tq = _a[0], representation = _a[1];
        this._update(new Uint8Array([tq]));
        if (representation.length > 0) {
            this._update(_escape(representation));
        }
        this._endMarker();
    };
    _Serializer.prototype._getBytes = function (type, value, isNull) {
        if (isNull) {
            return Uint8Array.from([type.binaryTypeId << 4 | 0x0F]);
        }
        else {
            var writer = ion_js_1.makeBinaryWriter();
            _Serializer._serializers[type.name](value, writer);
            writer.close();
            return writer.getBytes().slice(4);
        }
    };
    _Serializer.prototype._getLengthLength = function (bytes) {
        if ((bytes[0] & 0x0F) == 0x0E) {
            for (var i = 1; i < bytes.length; i++) {
                if ((bytes[i] & 0x80) != 0) {
                    return i;
                }
            }
            throw new Error("Problem while reading VarUInt!");
        }
        return 0;
    };
    _Serializer.prototype._scalarOrNullSplitParts = function (type, isNull, bytes) {
        var offset = 1 + this._getLengthLength(bytes);
        var representation = bytes.slice(offset);
        var tq = bytes[0];
        if (type == ion_js_1.IonTypes.SYMBOL) {
            tq = 0x70;
            if (isNull) {
                tq |= 0x0F;
            }
        }
        if (type != ion_js_1.IonTypes.BOOL
            && type != ion_js_1.IonTypes.SYMBOL
            && (tq & 0x0F) != 0x0F) {
            tq &= 0xF0;
        }
        return [tq, representation];
    };
    _Serializer.prototype._scalar = function (ionValue) {
        this._handleAnnotationsBegin(ionValue);
        this._beginMarker();
        var scalarBytes = this._getBytes(ionValue._type(), ionValue._value(), ionValue._isNull());
        var _a = this._scalarOrNullSplitParts(ionValue._type(), ionValue._isNull(), scalarBytes), tq = _a[0], representation = _a[1];
        this._update(new Uint8Array([tq]));
        if (representation.length > 0) {
            this._update(_escape(representation));
        }
        this._endMarker();
        this._handleAnnotationsEnd(ionValue);
    };
    _Serializer.prototype._stepIn = function (ionValue) {
        this._handleFieldName(ionValue._fieldName());
        this._handleAnnotationsBegin(ionValue, true);
        this._beginMarker();
        var tq = _TQ[ionValue._type().name];
        if (ionValue._isNull()) {
            tq |= 0x0F;
        }
        this._update(new Uint8Array([tq]));
    };
    _Serializer.prototype._stepOut = function () {
        this._endMarker();
        this._handleAnnotationsEnd(null, true);
    };
    _Serializer.prototype._digest = function () { return this._hashFunction.digest(); };
    _Serializer._serializers = {
        "null": function (value, writer) { writer.writeNull(ion_js_1.IonTypes.NULL); },
        "bool": function (value, writer) { writer.writeBoolean(value); },
        "int": function (value, writer) { writer.writeInt(value); },
        "float": function (value, writer) { writer.writeFloat64(value); },
        "decimal": function (value, writer) { writer.writeDecimal(value); },
        "timestamp": function (value, writer) { writer.writeTimestamp(value); },
        "symbol": function (value, writer) { writer.writeString(value); },
        "string": function (value, writer) { writer.writeString(value); },
        "clob": function (value, writer) { writer.writeClob(value); },
        "blob": function (value, writer) { writer.writeBlob(value); },
    };
    return _Serializer;
}());
var _StructSerializer = (function (_super) {
    __extends(_StructSerializer, _super);
    function _StructSerializer(hashFunction, depth, hashFunctionProvider) {
        var _this = _super.call(this, hashFunction, depth) || this;
        _this._fieldHashes = [];
        _this._scalarSerializer = new _Serializer(hashFunctionProvider(), depth + 1);
        _this._fieldHashes = [];
        return _this;
    }
    _StructSerializer.prototype._scalar = function (value) {
        this._scalarSerializer._handleFieldName(value._fieldName());
        this._scalarSerializer._scalar(value);
        var digest = this._scalarSerializer._digest();
        this._appendFieldHash(digest);
    };
    _StructSerializer.prototype._stepOut = function () {
        this._fieldHashes.sort(_Uint8ArrayComparator);
        for (var _i = 0, _a = this._fieldHashes; _i < _a.length; _i++) {
            var digest = _a[_i];
            this._update(_escape(digest));
        }
        _super.prototype._stepOut.call(this);
    };
    _StructSerializer.prototype._appendFieldHash = function (digest) {
        this._fieldHashes.push(digest);
    };
    return _StructSerializer;
}(_Serializer));
function _Uint8ArrayComparator(a, b) {
    var i = 0;
    while (i < a.length && i < b.length) {
        var a_byte = a[i];
        var b_byte = b[i];
        if (a_byte != b_byte) {
            if (a_byte - b_byte < 0) {
                return -1;
            }
            else {
                return 1;
            }
        }
        i += 1;
    }
    var len_diff = a.length - b.length;
    if (len_diff < 0) {
        return -1;
    }
    else if (len_diff > 0) {
        return 1;
    }
    else {
        return 0;
    }
}
exports._Uint8ArrayComparator = _Uint8ArrayComparator;
var _BEGIN_MARKER_BYTE = 0x0B;
var _END_MARKER_BYTE = 0x0E;
var _ESCAPE_BYTE = 0x0C;
var _BEGIN_MARKER = new Uint8Array([_BEGIN_MARKER_BYTE]);
var _END_MARKER = new Uint8Array([_END_MARKER_BYTE]);
var _TQ = {};
for (var ionType in ion_js_1.IonTypes) {
    _TQ[ionType.toLowerCase()] = ion_js_1.IonTypes[ionType].binaryTypeId << 4;
}
var _TQ_ANNOTATED_VALUE = new Uint8Array([0xE0]);
function _escape(bytes) {
    for (var i = 0; i < bytes.length; i++) {
        var b = bytes[i];
        if (b == _BEGIN_MARKER_BYTE || b == _END_MARKER_BYTE || b == _ESCAPE_BYTE) {
            var escapedBytes = [];
            for (var j = 0; j < bytes.length; j++) {
                var c = bytes[j];
                if (c == _BEGIN_MARKER_BYTE || c == _END_MARKER_BYTE || c == _ESCAPE_BYTE) {
                    escapedBytes.push(_ESCAPE_BYTE);
                }
                escapedBytes.push(c);
            }
            return new Uint8Array(escapedBytes);
        }
    }
    return bytes;
}
exports._escape = _escape;
//# sourceMappingURL=IonHashImpl.js.map