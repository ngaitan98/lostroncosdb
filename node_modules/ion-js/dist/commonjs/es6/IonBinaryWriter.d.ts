import { AbstractWriter } from "./AbstractWriter";
import { Decimal } from "./IonDecimal";
import { IonType } from "./IonType";
import { LocalSymbolTable } from "./IonLocalSymbolTable";
import { LowLevelBinaryWriter } from "./IonLowLevelBinaryWriter";
import { Timestamp } from "./IonTimestamp";
import { Writeable } from "./IonWriteable";
import JSBI from "jsbi";
declare enum TypeCodes {
    NULL = 0,
    BOOL = 1,
    POSITIVE_INT = 2,
    NEGATIVE_INT = 3,
    FLOAT = 4,
    DECIMAL = 5,
    TIMESTAMP = 6,
    SYMBOL = 7,
    STRING = 8,
    CLOB = 9,
    BLOB = 10,
    LIST = 11,
    SEXP = 12,
    STRUCT = 13,
    ANNOTATION = 14
}
export declare class BinaryWriter extends AbstractWriter {
    private readonly symbolTable;
    private readonly writer;
    private datagram;
    private containers;
    private fieldName;
    private state;
    constructor(symbolTable: LocalSymbolTable, writeable: Writeable);
    getBytes(): Uint8Array;
    writeBlob(value: Uint8Array): void;
    writeBoolean(value: boolean): void;
    writeClob(value: Uint8Array): void;
    writeDecimal(value: Decimal | string): void;
    writeFloat32(value: number): void;
    writeFloat64(value: number): void;
    writeInt(value: number | JSBI | null): void;
    writeNull(type?: IonType): void;
    writeString(value: string): void;
    writeSymbol(value: string): void;
    writeTimestamp(value: Timestamp): void;
    stepIn(type: IonType): void;
    stepOut(): void;
    writeFieldName(fieldName: string): void;
    depth(): number;
    close(): void;
    private writeIvm;
    private encodeAnnotations;
    private getCurrentContainer;
    private addNode;
    private checkWriteValue;
    private checkClosed;
    private writeSymbolTable;
    private writeImport;
}
export interface Node {
    isContainer(): boolean;
    addChild(child: Node, name?: Uint8Array): void;
    write(): void;
    getLength(): number;
}
export declare abstract class AbstractNode implements Node {
    private readonly _writer;
    private readonly parent;
    private readonly _type;
    private readonly annotations;
    protected constructor(_writer: LowLevelBinaryWriter, parent: Node, _type: IonType, annotations: Uint8Array);
    readonly typeCode: number;
    readonly writer: LowLevelBinaryWriter;
    static getLengthLength(length: number): number;
    writeTypeDescriptorAndLength(typeCode: TypeCodes, isNull: boolean, length: number): void;
    getContainedValueLength(): number;
    abstract getValueLength(): number;
    getAnnotatedContainerLength(): number;
    getAnnotationsLength(): number;
    getLength(): number;
    writeAnnotations(): void;
    abstract isContainer(): boolean;
    abstract addChild(child: Node, name?: Uint8Array): void;
    abstract write(): void;
    private hasAnnotations;
}
export declare abstract class LeafNode extends AbstractNode {
    addChild(child: Node, name?: Uint8Array): void;
    isContainer(): boolean;
}
export declare class NullNode extends LeafNode {
    constructor(writer: LowLevelBinaryWriter, parent: Node, type: IonType, annotations: Uint8Array);
    write(): void;
    getValueLength(): number;
}
export {};
