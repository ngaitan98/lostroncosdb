"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const AbstractWriter_1 = require("./AbstractWriter");
const IonDecimal_1 = require("./IonDecimal");
const IonUnicode_1 = require("./IonUnicode");
const IonTypes_1 = require("./IonTypes");
const IonLowLevelBinaryWriter_1 = require("./IonLowLevelBinaryWriter");
const IonTimestamp_1 = require("./IonTimestamp");
const IonWriteable_1 = require("./IonWriteable");
const util_1 = require("./util");
const jsbi_1 = __importDefault(require("jsbi"));
const JsbiSupport_1 = require("./JsbiSupport");
const JsbiSerde_1 = require("./JsbiSerde");
const MAJOR_VERSION = 1;
const MINOR_VERSION = 0;
const MAX_VALUE_LENGTH = 14;
const MAX_VALUE_LENGTH_FLAG = 14;
const NULL_VALUE_FLAG = 15;
const TYPE_DESCRIPTOR_LENGTH = 1;
var States;
(function (States) {
    States[States["VALUE"] = 0] = "VALUE";
    States[States["STRUCT_FIELD"] = 1] = "STRUCT_FIELD";
    States[States["STRUCT_VALUE"] = 2] = "STRUCT_VALUE";
    States[States["CLOSED"] = 3] = "CLOSED";
})(States || (States = {}));
var TypeCodes;
(function (TypeCodes) {
    TypeCodes[TypeCodes["NULL"] = 0] = "NULL";
    TypeCodes[TypeCodes["BOOL"] = 1] = "BOOL";
    TypeCodes[TypeCodes["POSITIVE_INT"] = 2] = "POSITIVE_INT";
    TypeCodes[TypeCodes["NEGATIVE_INT"] = 3] = "NEGATIVE_INT";
    TypeCodes[TypeCodes["FLOAT"] = 4] = "FLOAT";
    TypeCodes[TypeCodes["DECIMAL"] = 5] = "DECIMAL";
    TypeCodes[TypeCodes["TIMESTAMP"] = 6] = "TIMESTAMP";
    TypeCodes[TypeCodes["SYMBOL"] = 7] = "SYMBOL";
    TypeCodes[TypeCodes["STRING"] = 8] = "STRING";
    TypeCodes[TypeCodes["CLOB"] = 9] = "CLOB";
    TypeCodes[TypeCodes["BLOB"] = 10] = "BLOB";
    TypeCodes[TypeCodes["LIST"] = 11] = "LIST";
    TypeCodes[TypeCodes["SEXP"] = 12] = "SEXP";
    TypeCodes[TypeCodes["STRUCT"] = 13] = "STRUCT";
    TypeCodes[TypeCodes["ANNOTATION"] = 14] = "ANNOTATION";
})(TypeCodes || (TypeCodes = {}));
class BinaryWriter extends AbstractWriter_1.AbstractWriter {
    constructor(symbolTable, writeable) {
        super();
        this.datagram = [];
        this.containers = [];
        this.state = States.VALUE;
        this.symbolTable = symbolTable;
        this.writer = new IonLowLevelBinaryWriter_1.LowLevelBinaryWriter(writeable);
    }
    getBytes() {
        return this.writer.getBytes();
    }
    writeBlob(value) {
        this.checkWriteValue();
        if (value === null || value === undefined) {
            this.writeNull(IonTypes_1.IonTypes.BLOB);
            return;
        }
        this.addNode(new BytesNode(this.writer, this.getCurrentContainer(), IonTypes_1.IonTypes.BLOB, this.encodeAnnotations(this._annotations), value));
    }
    writeBoolean(value) {
        this.checkWriteValue();
        if (value === null || value === undefined) {
            this.writeNull(IonTypes_1.IonTypes.BOOL);
            return;
        }
        this.addNode(new BooleanNode(this.writer, this.getCurrentContainer(), this.encodeAnnotations(this._annotations), value));
    }
    writeClob(value) {
        this.checkWriteValue();
        if (value === null || value === undefined) {
            this.writeNull(IonTypes_1.IonTypes.CLOB);
            return;
        }
        this.addNode(new BytesNode(this.writer, this.getCurrentContainer(), IonTypes_1.IonTypes.CLOB, this.encodeAnnotations(this._annotations), value));
    }
    writeDecimal(value) {
        this.checkWriteValue();
        if (value === null || value === undefined) {
            this.writeNull(IonTypes_1.IonTypes.DECIMAL);
            return;
        }
        if (typeof value == 'string')
            value = IonDecimal_1.Decimal.parse(value);
        let exponent = value.getExponent();
        let coefficient = value.getCoefficient();
        let isPositiveZero = jsbi_1.default.equal(coefficient, JsbiSupport_1.JsbiSupport.ZERO) && !value.isNegative();
        if (isPositiveZero && exponent === 0 && util_1._sign(exponent) === 1) {
            this.addNode(new BytesNode(this.writer, this.getCurrentContainer(), IonTypes_1.IonTypes.DECIMAL, this.encodeAnnotations(this._annotations), new Uint8Array(0)));
            return;
        }
        let isNegative = value.isNegative();
        let writeCoefficient = isNegative || jsbi_1.default.notEqual(coefficient, JsbiSupport_1.JsbiSupport.ZERO);
        let coefficientBytes = writeCoefficient ? JsbiSerde_1.JsbiSerde.toSignedIntBytes(coefficient, isNegative) : null;
        let bufLen = IonLowLevelBinaryWriter_1.LowLevelBinaryWriter.getVariableLengthSignedIntSize(exponent) + (writeCoefficient ? coefficientBytes.length : 0);
        let writer = new IonLowLevelBinaryWriter_1.LowLevelBinaryWriter(new IonWriteable_1.Writeable(bufLen));
        writer.writeVariableLengthSignedInt(exponent);
        if (writeCoefficient) {
            writer.writeBytes(coefficientBytes);
        }
        this.addNode(new BytesNode(this.writer, this.getCurrentContainer(), IonTypes_1.IonTypes.DECIMAL, this.encodeAnnotations(this._annotations), writer.getBytes()));
    }
    writeFloat32(value) {
        this.checkWriteValue();
        if (value === null || value === undefined) {
            this.writeNull(IonTypes_1.IonTypes.FLOAT);
            return;
        }
        let bytes;
        if (Object.is(value, 0)) {
            bytes = new Uint8Array(0);
        }
        else {
            let buffer = new ArrayBuffer(4);
            let dataview = new DataView(buffer);
            dataview.setFloat32(0, value, false);
            bytes = new Uint8Array(buffer);
        }
        this.addNode(new BytesNode(this.writer, this.getCurrentContainer(), IonTypes_1.IonTypes.FLOAT, this.encodeAnnotations(this._annotations), bytes));
    }
    writeFloat64(value) {
        this.checkWriteValue();
        if (value === null || value === undefined) {
            this.writeNull(IonTypes_1.IonTypes.FLOAT);
            return;
        }
        let bytes;
        if (Object.is(value, 0)) {
            bytes = new Uint8Array(0);
        }
        else {
            let buffer = new ArrayBuffer(8);
            let dataview = new DataView(buffer);
            dataview.setFloat64(0, value, false);
            bytes = new Uint8Array(buffer);
        }
        this.addNode(new BytesNode(this.writer, this.getCurrentContainer(), IonTypes_1.IonTypes.FLOAT, this.encodeAnnotations(this._annotations), bytes));
    }
    writeInt(value) {
        this.checkWriteValue();
        if (value === null || value === undefined) {
            this.writeNull(IonTypes_1.IonTypes.INT);
            return;
        }
        this.addNode(new IntNode(this.writer, this.getCurrentContainer(), this.encodeAnnotations(this._annotations), value));
    }
    writeNull(type = IonTypes_1.IonTypes.NULL) {
        this.checkWriteValue();
        this.addNode(new NullNode(this.writer, this.getCurrentContainer(), type, this.encodeAnnotations(this._annotations)));
    }
    writeString(value) {
        this.checkWriteValue();
        if (value === null || value === undefined) {
            this.writeNull(IonTypes_1.IonTypes.STRING);
            return;
        }
        this.addNode(new BytesNode(this.writer, this.getCurrentContainer(), IonTypes_1.IonTypes.STRING, this.encodeAnnotations(this._annotations), IonUnicode_1.encodeUtf8(value)));
    }
    writeSymbol(value) {
        this.checkWriteValue();
        if (value === null || value === undefined) {
            this.writeNull(IonTypes_1.IonTypes.SYMBOL);
        }
        else {
            let symbolId = this.symbolTable.addSymbol(value);
            let writer = new IonLowLevelBinaryWriter_1.LowLevelBinaryWriter(new IonWriteable_1.Writeable(IonLowLevelBinaryWriter_1.LowLevelBinaryWriter.getUnsignedIntSize(symbolId)));
            writer.writeUnsignedInt(symbolId);
            this.addNode(new BytesNode(this.writer, this.getCurrentContainer(), IonTypes_1.IonTypes.SYMBOL, this.encodeAnnotations(this._annotations), writer.getBytes()));
        }
    }
    writeTimestamp(value) {
        this.checkWriteValue();
        if (value === null || value === undefined) {
            this.writeNull(IonTypes_1.IonTypes.TIMESTAMP);
            return;
        }
        let writer = new IonLowLevelBinaryWriter_1.LowLevelBinaryWriter(new IonWriteable_1.Writeable(12));
        writer.writeVariableLengthSignedInt(value.getLocalOffset());
        let date = value.getDate();
        writer.writeVariableLengthUnsignedInt(date.getUTCFullYear());
        if (value.getPrecision() >= IonTimestamp_1.TimestampPrecision.MONTH) {
            writer.writeVariableLengthUnsignedInt(date.getUTCMonth() + 1);
        }
        if (value.getPrecision() >= IonTimestamp_1.TimestampPrecision.DAY) {
            writer.writeVariableLengthUnsignedInt(date.getUTCDate());
        }
        if (value.getPrecision() >= IonTimestamp_1.TimestampPrecision.HOUR_AND_MINUTE) {
            writer.writeVariableLengthUnsignedInt(date.getUTCHours());
            writer.writeVariableLengthUnsignedInt(date.getUTCMinutes());
        }
        if (value.getPrecision() >= IonTimestamp_1.TimestampPrecision.SECONDS) {
            writer.writeVariableLengthUnsignedInt(value.getSecondsInt());
            let fractionalSeconds = value._getFractionalSeconds();
            if (fractionalSeconds.getExponent() !== 0) {
                writer.writeVariableLengthSignedInt(fractionalSeconds.getExponent());
                if (!JsbiSupport_1.JsbiSupport.isZero(fractionalSeconds.getCoefficient())) {
                    writer.writeBytes(JsbiSerde_1.JsbiSerde.toSignedIntBytes(fractionalSeconds.getCoefficient(), fractionalSeconds.isNegative()));
                }
            }
        }
        this.addNode(new BytesNode(this.writer, this.getCurrentContainer(), IonTypes_1.IonTypes.TIMESTAMP, this.encodeAnnotations(this._annotations), writer.getBytes()));
    }
    stepIn(type) {
        this.checkWriteValue();
        switch (type) {
            case IonTypes_1.IonTypes.LIST:
            case IonTypes_1.IonTypes.SEXP:
                this.addNode(new SequenceNode(this.writer, this.getCurrentContainer(), type, this.encodeAnnotations(this._annotations)));
                break;
            case IonTypes_1.IonTypes.STRUCT:
                this.addNode(new StructNode(this.writer, this.getCurrentContainer(), this.encodeAnnotations(this._annotations)));
                this.state = States.STRUCT_FIELD;
                break;
            default:
                throw new Error("Unrecognized container type");
        }
    }
    stepOut() {
        if (this.depth() === 0) {
            throw new Error("Not currently in a container");
        }
        if (this.state === States.STRUCT_VALUE) {
            throw new Error("Cannot exit a struct with a partially written field");
        }
        this.containers.pop();
        if (this.depth() > 0) {
            this.state = this.getCurrentContainer() instanceof StructNode
                ? States.STRUCT_FIELD
                : States.VALUE;
        }
        else {
            this.state = States.VALUE;
        }
    }
    writeFieldName(fieldName) {
        if (this.state !== States.STRUCT_FIELD) {
            throw new Error("Cannot write a field name outside of a struct");
        }
        this.fieldName = this.encodeAnnotations([fieldName]);
        this.state = States.STRUCT_VALUE;
    }
    depth() {
        return this.containers.length;
    }
    close() {
        this.checkClosed();
        if (this.depth() > 0) {
            throw new Error("Writer has one or more open containers; call stepOut() for each container prior to close()");
        }
        this.writeIvm();
        let datagram = this.datagram;
        this.datagram = [];
        this.writeSymbolTable();
        for (let node of datagram) {
            node.write();
        }
        this.state = States.CLOSED;
    }
    writeIvm() {
        this.writer.writeByte(0xE0);
        this.writer.writeByte(MAJOR_VERSION);
        this.writer.writeByte(MINOR_VERSION);
        this.writer.writeByte(0xEA);
    }
    encodeAnnotations(annotations) {
        if (annotations.length === 0) {
            return new Uint8Array(0);
        }
        let writeable = new IonWriteable_1.Writeable();
        let writer = new IonLowLevelBinaryWriter_1.LowLevelBinaryWriter(writeable);
        for (let annotation of annotations) {
            let symbolId = this.symbolTable.addSymbol(annotation);
            writer.writeVariableLengthUnsignedInt(symbolId);
        }
        this._clearAnnotations();
        return writeable.getBytes();
    }
    getCurrentContainer() {
        return this.containers[this.containers.length - 1];
    }
    addNode(node) {
        if (this.depth() === 0) {
            this.datagram.push(node);
        }
        else {
            if (this.state === States.STRUCT_VALUE) {
                this.getCurrentContainer().addChild(node, this.fieldName);
                this.state = States.STRUCT_FIELD;
            }
            else {
                this.getCurrentContainer().addChild(node);
            }
        }
        if (node.isContainer()) {
            this.containers.push(node);
            this.state = States.VALUE;
        }
    }
    checkWriteValue() {
        this.checkClosed();
        if (this.state === States.STRUCT_FIELD) {
            throw new Error("Expected a struct field name instead of a value, call writeFieldName(string) with the desired name before calling stepIn(IonType) or writeIonType()");
        }
    }
    checkClosed() {
        if (this.state === States.CLOSED) {
            throw new Error("Writer is closed, no further operations are available");
        }
    }
    writeSymbolTable() {
        let hasImports = this.symbolTable.import.symbolTable.name != "$ion";
        let hasLocalSymbols = this.symbolTable.symbols.length > 0;
        if (!(hasImports || hasLocalSymbols)) {
            return;
        }
        this.setAnnotations(['$ion_symbol_table']);
        this.stepIn(IonTypes_1.IonTypes.STRUCT);
        if (hasImports) {
            this.writeFieldName('imports');
            this.stepIn(IonTypes_1.IonTypes.LIST);
            this.writeImport(this.symbolTable.import);
            this.stepOut();
        }
        if (hasLocalSymbols) {
            this.writeFieldName('symbols');
            this.stepIn(IonTypes_1.IonTypes.LIST);
            for (let symbol_ of this.symbolTable.symbols) {
                if (symbol_ !== undefined) {
                    this.writeString(symbol_);
                }
            }
            this.stepOut();
        }
        this.stepOut();
        this.datagram[0].write();
    }
    writeImport(import_) {
        if (!import_) {
            return;
        }
        this.writeImport(import_.parent);
        this.stepIn(IonTypes_1.IonTypes.STRUCT);
        this.writeFieldName('name');
        this.writeString(import_.symbolTable.name);
        this.writeFieldName('version');
        this.writeInt(import_.symbolTable.version);
        this.writeFieldName('max_id');
        this.writeInt(import_.length);
        this.stepOut();
    }
}
exports.BinaryWriter = BinaryWriter;
class AbstractNode {
    constructor(_writer, parent, _type, annotations) {
        this._writer = _writer;
        this.parent = parent;
        this._type = _type;
        this.annotations = annotations;
    }
    get typeCode() {
        return this._type.binaryTypeId;
    }
    get writer() {
        return this._writer;
    }
    static getLengthLength(length) {
        if (length < MAX_VALUE_LENGTH) {
            return 0;
        }
        else {
            return IonLowLevelBinaryWriter_1.LowLevelBinaryWriter.getVariableLengthUnsignedIntSize(length);
        }
    }
    writeTypeDescriptorAndLength(typeCode, isNull, length) {
        let typeDescriptor = typeCode << 4;
        if (isNull) {
            typeDescriptor |= NULL_VALUE_FLAG;
            this.writer.writeByte(typeDescriptor);
        }
        else if (length < MAX_VALUE_LENGTH) {
            typeDescriptor |= length;
            this.writer.writeByte(typeDescriptor);
        }
        else {
            typeDescriptor |= MAX_VALUE_LENGTH_FLAG;
            this.writer.writeByte(typeDescriptor);
            this.writer.writeVariableLengthUnsignedInt(length);
        }
    }
    getContainedValueLength() {
        let valueLength = this.getValueLength();
        let valueLengthLength = AbstractNode.getLengthLength(valueLength);
        return TYPE_DESCRIPTOR_LENGTH + valueLengthLength + valueLength;
    }
    getAnnotatedContainerLength() {
        let annotationsLength = this.annotations.length;
        let annotationsLengthLength = IonLowLevelBinaryWriter_1.LowLevelBinaryWriter.getVariableLengthUnsignedIntSize(annotationsLength);
        let containedValueLength = this.getContainedValueLength();
        return annotationsLength + annotationsLengthLength + containedValueLength;
    }
    getAnnotationsLength() {
        if (this.hasAnnotations()) {
            let annotationsLength = this.annotations.length;
            let annotationsLengthLength = IonLowLevelBinaryWriter_1.LowLevelBinaryWriter.getVariableLengthUnsignedIntSize(annotationsLength);
            let containedValueLength = this.getContainedValueLength();
            let containedValueLengthLength = AbstractNode.getLengthLength(containedValueLength);
            return TYPE_DESCRIPTOR_LENGTH + containedValueLengthLength + annotationsLengthLength + annotationsLength;
        }
        return 0;
    }
    getLength() {
        let annotationsLength = this.getAnnotationsLength();
        let containedValueLength = this.getContainedValueLength();
        return annotationsLength + containedValueLength;
    }
    writeAnnotations() {
        if (!this.hasAnnotations()) {
            return;
        }
        let annotatedContainerLength = this.getAnnotatedContainerLength();
        this.writeTypeDescriptorAndLength(TypeCodes.ANNOTATION, false, annotatedContainerLength);
        this.writer.writeVariableLengthUnsignedInt(this.annotations.length);
        this.writer.writeBytes(new Uint8Array(this.annotations));
    }
    hasAnnotations() {
        return this.annotations.length > 0;
    }
}
exports.AbstractNode = AbstractNode;
class ContainerNode extends AbstractNode {
    constructor(writer, parent, type, annotations) {
        super(writer, parent, type, annotations);
    }
    isContainer() {
        return true;
    }
}
class SequenceNode extends ContainerNode {
    constructor(writer, parent, type, annotations) {
        super(writer, parent, type, annotations);
        this.children = [];
    }
    addChild(child, name) {
        this.children.push(child);
    }
    write() {
        this.writeAnnotations();
        this.writeTypeDescriptorAndLength(this.typeCode, false, this.getValueLength());
        for (let child of this.children) {
            child.write();
        }
    }
    getValueLength() {
        let valueLength = 0;
        for (let child of this.children) {
            valueLength += child.getLength();
        }
        return valueLength;
    }
    getLength() {
        if (this.length === undefined) {
            this.length = super.getLength();
        }
        return this.length;
    }
}
class StructNode extends ContainerNode {
    constructor(writer, parent, annotations) {
        super(writer, parent, IonTypes_1.IonTypes.STRUCT, annotations);
        this.fields = [];
    }
    addChild(child, fieldName) {
        if (fieldName === null || fieldName === undefined)
            throw new Error("Cannot add a value to a struct without a field name");
        this.fields.push({ name: fieldName, value: child });
    }
    getValueLength() {
        let valueLength = 0;
        for (let field of this.fields) {
            valueLength += field.name.length;
            valueLength += field.value.getLength();
        }
        return valueLength;
    }
    getLength() {
        if (this.length === undefined) {
            this.length = super.getLength();
        }
        return this.length;
    }
    write() {
        this.writeAnnotations();
        this.writeTypeDescriptorAndLength(this.typeCode, false, this.getValueLength());
        for (let field of this.fields) {
            this.writer.writeBytes(new Uint8Array(field.name));
            field.value.write();
        }
    }
}
class LeafNode extends AbstractNode {
    addChild(child, name) {
        throw new Error("Cannot add a child to a leaf node");
    }
    isContainer() {
        return false;
    }
}
exports.LeafNode = LeafNode;
class BooleanNode extends LeafNode {
    constructor(writer, parent, annotations, value) {
        super(writer, parent, IonTypes_1.IonTypes.BOOL, annotations);
        this.value = value;
    }
    write() {
        this.writeAnnotations();
        this.writeTypeDescriptorAndLength(this.typeCode, false, this.value ? 1 : 0);
    }
    getValueLength() {
        return 0;
    }
}
class IntNode extends LeafNode {
    constructor(writer, parent, annotations, value) {
        super(writer, parent, IonTypes_1.IonTypes.INT, annotations);
        this.value = value;
        if (!(typeof this.value === 'number' || this.value instanceof jsbi_1.default)) {
            throw new Error('Expected ' + this.value + ' to be a number or JSBI');
        }
        if (jsbi_1.default.GT(this.value, 0)) {
            this.intTypeCode = TypeCodes.POSITIVE_INT;
            let writer = new IonLowLevelBinaryWriter_1.LowLevelBinaryWriter(new IonWriteable_1.Writeable(IonLowLevelBinaryWriter_1.LowLevelBinaryWriter.getUnsignedIntSize(this.value)));
            writer.writeUnsignedInt(this.value);
            this.bytes = writer.getBytes();
        }
        else if (jsbi_1.default.LT(this.value, 0)) {
            this.intTypeCode = TypeCodes.NEGATIVE_INT;
            let magnitude;
            if (value instanceof jsbi_1.default) {
                if (JsbiSupport_1.JsbiSupport.isNegative(value)) {
                    magnitude = jsbi_1.default.unaryMinus(value);
                }
            }
            else {
                magnitude = Math.abs(value);
            }
            let writer = new IonLowLevelBinaryWriter_1.LowLevelBinaryWriter(new IonWriteable_1.Writeable(IonLowLevelBinaryWriter_1.LowLevelBinaryWriter.getUnsignedIntSize(magnitude)));
            writer.writeUnsignedInt(magnitude);
            this.bytes = writer.getBytes();
        }
        else {
            this.intTypeCode = TypeCodes.POSITIVE_INT;
            this.bytes = new Uint8Array(0);
        }
    }
    write() {
        this.writeAnnotations();
        this.writeTypeDescriptorAndLength(this.intTypeCode, false, this.bytes.length);
        this.writer.writeBytes(this.bytes);
    }
    getValueLength() {
        return this.bytes.length;
    }
}
class BytesNode extends LeafNode {
    constructor(writer, parent, type, annotations, value) {
        super(writer, parent, type, annotations);
        this.value = value;
    }
    write() {
        this.writeAnnotations();
        this.writeTypeDescriptorAndLength(this.typeCode, false, this.value.length);
        this.writer.writeBytes(this.value);
    }
    getValueLength() {
        return this.value.length;
    }
}
class NullNode extends LeafNode {
    constructor(writer, parent, type, annotations) {
        super(writer, parent, type, annotations);
    }
    write() {
        this.writeAnnotations();
        this.writeTypeDescriptorAndLength(this.typeCode, true, 0);
    }
    getValueLength() {
        return 0;
    }
}
exports.NullNode = NullNode;
//# sourceMappingURL=IonBinaryWriter.js.map