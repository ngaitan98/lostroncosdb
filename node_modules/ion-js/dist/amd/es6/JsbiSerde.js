var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
define(["require", "exports", "jsbi", "./JsbiSupport"], function (require, exports, jsbi_1, JsbiSupport_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    jsbi_1 = __importDefault(jsbi_1);
    class JsbiSerde {
        static toSignedIntBytes(value, isNegative) {
            let bytes = this.toUnsignedIntBytes(value);
            if (bytes[0] >= 128) {
                let extendedBytes = new Uint8Array(bytes.length + 1);
                extendedBytes.set(bytes, 1);
                bytes = extendedBytes;
            }
            if (isNegative) {
                bytes[0] += 0x80;
            }
            return bytes;
        }
        static fromUnsignedBytes(bytes) {
            let magnitude = JsbiSupport_1.JsbiSupport.ZERO;
            for (let m = 0; m < bytes.length; m++) {
                let byte = jsbi_1.default.BigInt(bytes[m]);
                magnitude = jsbi_1.default.leftShift(magnitude, this.BITS_PER_BYTE);
                magnitude = jsbi_1.default.bitwiseOr(magnitude, byte);
            }
            return magnitude;
        }
        static toUnsignedIntBytes(value) {
            if (JsbiSupport_1.JsbiSupport.isNegative(value)) {
                value = jsbi_1.default.unaryMinus(value);
            }
            let sizeInBytes = this.getUnsignedIntSizeInBytes(value);
            let bytes = new Uint8Array(sizeInBytes);
            for (let m = sizeInBytes - 1; m >= 0; m--) {
                let lastByte = jsbi_1.default.toNumber(jsbi_1.default.bitwiseAnd(value, this.BYTE_MAX_VALUE));
                value = jsbi_1.default.signedRightShift(value, this.BITS_PER_BYTE);
                bytes[m] = lastByte;
            }
            return bytes;
        }
        static getUnsignedIntSizeInBytes(value) {
            for (let m = 0; m < this.SIZE_THRESHOLDS.length; m++) {
                let threshold = this.SIZE_THRESHOLDS[m];
                if (jsbi_1.default.lessThanOrEqual(value, threshold)) {
                    return m + 1;
                }
            }
            let sizeInBytes = this.SIZE_THRESHOLDS.length;
            let threshold = this.calculateSizeThreshold(sizeInBytes);
            while (jsbi_1.default.greaterThan(value, threshold)) {
                sizeInBytes++;
                threshold = this.calculateSizeThreshold(sizeInBytes);
            }
            return sizeInBytes;
        }
        static calculateSizeThresholds() {
            let thresholds = [];
            for (let m = 1; m <= this.SERIALIZED_JSBI_SIZES_TO_PRECOMPUTE; m++) {
                thresholds.push(this.calculateSizeThreshold(m));
            }
            return thresholds;
        }
        static calculateSizeThreshold(numberOfBytes) {
            let exponent = jsbi_1.default.multiply(jsbi_1.default.BigInt(numberOfBytes), this.BITS_PER_BYTE);
            let threshold = jsbi_1.default.exponentiate(JsbiSupport_1.JsbiSupport.TWO, exponent);
            return jsbi_1.default.subtract(threshold, JsbiSupport_1.JsbiSupport.ONE);
        }
    }
    exports.JsbiSerde = JsbiSerde;
    JsbiSerde.SERIALIZED_JSBI_SIZES_TO_PRECOMPUTE = 64;
    JsbiSerde.BITS_PER_BYTE = jsbi_1.default.BigInt(8);
    JsbiSerde.BYTE_MAX_VALUE = jsbi_1.default.BigInt(0xFF);
    JsbiSerde.SIZE_THRESHOLDS = JsbiSerde.calculateSizeThresholds();
});
//# sourceMappingURL=JsbiSerde.js.map