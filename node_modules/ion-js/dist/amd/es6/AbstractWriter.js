define(["require", "exports", "./IonTypes"], function (require, exports, IonTypes_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class AbstractWriter {
        constructor() {
            this._annotations = [];
        }
        addAnnotation(annotation) {
            if (!this._isString(annotation)) {
                throw new Error('Annotation must be of type string.');
            }
            this._annotations.push(annotation);
        }
        setAnnotations(annotations) {
            if (annotations === undefined || annotations === null) {
                throw new Error('Annotations were undefined or null.');
            }
            else if (!this._validateAnnotations(annotations)) {
                throw new Error('Annotations must be of type string[].');
            }
            else {
                this._annotations = annotations;
            }
        }
        writeValues(reader) {
            this._writeValues(reader);
        }
        writeValue(reader) {
            this._writeValue(reader);
        }
        _clearAnnotations() {
            this._annotations = [];
        }
        _writeValues(reader, _depth = 0) {
            let type = reader.type();
            if (type === null) {
                type = reader.next();
            }
            while (type !== null) {
                this._writeValue(reader, _depth);
                type = reader.next();
            }
        }
        _writeValue(reader, _depth = 0) {
            let type = reader.type();
            if (type === null) {
                return;
            }
            if (_depth > 0) {
                if (reader.fieldName() != null) {
                    this.writeFieldName(reader.fieldName());
                }
            }
            this.setAnnotations(reader.annotations());
            if (reader.isNull()) {
                this.writeNull(type);
            }
            else {
                switch (type) {
                    case IonTypes_1.IonTypes.BOOL:
                        this.writeBoolean(reader.booleanValue());
                        break;
                    case IonTypes_1.IonTypes.INT:
                        this.writeInt(reader.bigIntValue());
                        break;
                    case IonTypes_1.IonTypes.FLOAT:
                        this.writeFloat64(reader.numberValue());
                        break;
                    case IonTypes_1.IonTypes.DECIMAL:
                        this.writeDecimal(reader.decimalValue());
                        break;
                    case IonTypes_1.IonTypes.TIMESTAMP:
                        this.writeTimestamp(reader.timestampValue());
                        break;
                    case IonTypes_1.IonTypes.SYMBOL:
                        this.writeSymbol(reader.stringValue());
                        break;
                    case IonTypes_1.IonTypes.STRING:
                        this.writeString(reader.stringValue());
                        break;
                    case IonTypes_1.IonTypes.CLOB:
                        this.writeClob(reader.byteValue());
                        break;
                    case IonTypes_1.IonTypes.BLOB:
                        this.writeBlob(reader.byteValue());
                        break;
                    case IonTypes_1.IonTypes.LIST:
                        this.stepIn(IonTypes_1.IonTypes.LIST);
                        break;
                    case IonTypes_1.IonTypes.SEXP:
                        this.stepIn(IonTypes_1.IonTypes.SEXP);
                        break;
                    case IonTypes_1.IonTypes.STRUCT:
                        this.stepIn(IonTypes_1.IonTypes.STRUCT);
                        break;
                    default: throw new Error('Unrecognized type ' + (type !== null ? type.name : type));
                }
                if (type.isContainer) {
                    reader.stepIn();
                    this._writeValues(reader, _depth + 1);
                    this.stepOut();
                    reader.stepOut();
                }
            }
        }
        _validateAnnotations(input) {
            if (!Array.isArray(input)) {
                return false;
            }
            for (let i = 0; i < input.length; i++) {
                if (!this._isString(input[i])) {
                    return false;
                }
            }
            return true;
        }
        _isString(input) {
            return typeof input === 'string';
        }
    }
    exports.AbstractWriter = AbstractWriter;
});
//# sourceMappingURL=AbstractWriter.js.map