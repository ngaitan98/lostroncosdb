"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const IonSystemSymbolTable_1 = require("./IonSystemSymbolTable");
const IonImport_1 = require("./IonImport");
const IonLocalSymbolTable_1 = require("./IonLocalSymbolTable");
const IonSubstituteSymbolTable_1 = require("./IonSubstituteSymbolTable");
exports.ion_symbol_table = "$ion_symbol_table";
exports.ion_symbol_table_sid = 3;
const empty_struct = {};
function load_imports(reader, catalog) {
    let import_ = IonSystemSymbolTable_1.getSystemSymbolTableImport();
    reader.stepIn();
    while (reader.next()) {
        reader.stepIn();
        let name;
        let version = 1;
        let maxId;
        while (reader.next()) {
            switch (reader.fieldName()) {
                case "name":
                    name = reader.stringValue();
                    break;
                case "version":
                    version = reader.numberValue();
                    break;
                case "max_id":
                    maxId = reader.numberValue();
            }
        }
        if (version < 1) {
            version = 1;
        }
        if (name && name !== "$ion") {
            let symbolTable = catalog.getVersion(name, version);
            if (!symbolTable) {
                if (maxId === undefined) {
                    throw new Error(`No exact match found when trying to import symbol table ${name} version ${version}`);
                }
                else {
                    symbolTable = catalog.getTable(name);
                }
            }
            if (!symbolTable) {
                symbolTable = new IonSubstituteSymbolTable_1.SubstituteSymbolTable(maxId);
            }
            import_ = new IonImport_1.Import(import_, symbolTable, maxId);
        }
        reader.stepOut();
    }
    reader.stepOut();
    return import_;
}
function load_symbols(reader) {
    let symbols = [];
    reader.stepIn();
    while (reader.next()) {
        symbols.push(reader.stringValue());
    }
    reader.stepOut();
    return symbols;
}
function makeSymbolTable(catalog, reader) {
    let import_;
    let symbols;
    let maxId;
    let foundSymbols = false;
    let foundImports = false;
    reader.stepIn();
    while (reader.next()) {
        switch (reader.fieldName()) {
            case "imports":
                if (foundImports)
                    throw new Error("Multiple import fields found.");
                import_ = load_imports(reader, catalog);
                foundImports = true;
                break;
            case "symbols":
                if (foundSymbols)
                    throw new Error("Multiple symbol fields found.");
                symbols = load_symbols(reader);
                foundSymbols = true;
                break;
        }
    }
    reader.stepOut();
    return new IonLocalSymbolTable_1.LocalSymbolTable(import_, symbols);
}
exports.makeSymbolTable = makeSymbolTable;
//# sourceMappingURL=IonSymbols.js.map