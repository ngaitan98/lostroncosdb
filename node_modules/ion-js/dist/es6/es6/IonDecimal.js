"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const jsbi_1 = __importDefault(require("jsbi"));
const util_1 = require("./util");
const JsbiSupport_1 = require("./JsbiSupport");
class Decimal {
    constructor(coefficient, exponent, isNegative) {
        if (typeof coefficient === "string") {
            return Decimal.parse(coefficient);
        }
        if (!util_1._hasValue(exponent)) {
            throw new Error("Decimal's constructor was called with a numeric coefficient but no exponent.");
        }
        if (typeof coefficient === "number") {
            return Decimal._fromNumberCoefficient(coefficient, exponent);
        }
        if (coefficient instanceof jsbi_1.default) {
            if (!util_1._hasValue(isNegative)) {
                isNegative = JsbiSupport_1.JsbiSupport.isNegative(coefficient);
            }
            else if (isNegative != JsbiSupport_1.JsbiSupport.isNegative(coefficient)) {
                coefficient = jsbi_1.default.unaryMinus(coefficient);
            }
            return Decimal._fromBigIntCoefficient(isNegative, coefficient, exponent);
        }
        throw new Error(`Unsupported parameter set (${coefficient}, ${exponent}, ${isNegative} passed to Decimal constructor.`);
    }
    static _fromNumberCoefficient(coefficient, exponent) {
        if (!Number.isInteger(coefficient)) {
            throw new Error("The provided coefficient was not an integer. (" + coefficient + ")");
        }
        let isNegative = coefficient < 0 || Object.is(coefficient, -0);
        return this._fromBigIntCoefficient(isNegative, jsbi_1.default.BigInt(coefficient), exponent);
    }
    static _fromBigIntCoefficient(isNegative, coefficient, exponent) {
        let value = Object.create(this.prototype);
        value._initialize(isNegative, coefficient, exponent);
        return value;
    }
    static parse(str) {
        let exponent = 0;
        if (str === 'null' || str === 'null.decimal')
            return null;
        let d = str.match('[d|D]');
        let exponentDelimiterIndex = str.length;
        if (d) {
            exponent = Number(str.substring(d.index + 1, str.length));
            exponentDelimiterIndex = d.index;
        }
        let f = str.match('\\.');
        let coefficientText;
        if (f) {
            let exponentShift = d ? (d.index - 1) - f.index : (str.length - 1) - f.index;
            exponent -= exponentShift;
            coefficientText = str.substring(0, f.index) + str.substring(f.index + 1, exponentDelimiterIndex);
        }
        else {
            coefficientText = str.substring(0, exponentDelimiterIndex);
        }
        let coefficient = jsbi_1.default.BigInt(coefficientText);
        let isNegative = JsbiSupport_1.JsbiSupport.isNegative(coefficient) || (coefficientText.startsWith("-0"));
        return Decimal._fromBigIntCoefficient(isNegative, coefficient, exponent);
    }
    isNegative() {
        return this._isNegative;
    }
    numberValue() {
        if (this._isNegativeZero()) {
            return -0;
        }
        return jsbi_1.default.toNumber(this._coefficient) * Math.pow(10, this._exponent);
    }
    intValue() {
        return Math.trunc(this.numberValue());
    }
    toString() {
        let cStr = this._coefficient.toString();
        if (cStr[0] === '-') {
            cStr = cStr.substr(1, cStr.length);
        }
        let precision = cStr.length;
        let adjustedExponent = this._exponent + (precision - 1);
        let s = '';
        if (this._exponent <= 0 && adjustedExponent >= -6) {
            if (this._exponent === 0) {
                s += cStr;
            }
            else {
                if (cStr.length <= -this._exponent) {
                    cStr = '0'.repeat(-this._exponent - cStr.length + 1) + cStr;
                    s += cStr.substr(0, 1) + '.' + cStr.substr(1);
                }
                else {
                    s += cStr.substr(0, precision + this._exponent) + '.' + cStr.substr(precision + this._exponent);
                }
            }
        }
        else {
            s += cStr[0];
            if (cStr.length > 1) {
                s += '.' + cStr.substr(1);
            }
            s += 'E' + (adjustedExponent > 0 ? '+' : '') + adjustedExponent;
        }
        return (this.isNegative() ? '-' : '') + s;
    }
    getCoefficient() {
        return this._coefficient;
    }
    getExponent() {
        return this._exponent;
    }
    equals(that) {
        return this.getExponent() === that.getExponent()
            && util_1._sign(this.getExponent()) === util_1._sign(that.getExponent())
            && this.isNegative() === that.isNegative()
            && jsbi_1.default.equal(this.getCoefficient(), that.getCoefficient());
    }
    compareTo(that) {
        if (JsbiSupport_1.JsbiSupport.isZero(this._coefficient)
            && JsbiSupport_1.JsbiSupport.isZero(that._coefficient)) {
            return 0;
        }
        let neg = this.isNegative();
        if (neg !== that.isNegative()) {
            return neg ? -1 : 1;
        }
        let [thisCoefficientStr, thisPrecision, thisMagnitude] = this._compareToParams();
        let [thatCoefficientStr, thatPrecision, thatMagnitude] = that._compareToParams();
        if (thisMagnitude > thatMagnitude) {
            return neg ? -1 : 1;
        }
        else if (thisMagnitude < thatMagnitude) {
            return neg ? 1 : -1;
        }
        if (thisCoefficientStr.length < thatCoefficientStr.length) {
            thisCoefficientStr += '0'.repeat(thatPrecision - thisPrecision);
        }
        else if (thisCoefficientStr.length > thatCoefficientStr.length) {
            thatCoefficientStr += '0'.repeat(thisPrecision - thatPrecision);
        }
        let thisJsbi = jsbi_1.default.BigInt(thisCoefficientStr);
        let thatJsbi = jsbi_1.default.BigInt(thatCoefficientStr);
        if (jsbi_1.default.greaterThan(thisJsbi, thatJsbi)) {
            return neg ? -1 : 1;
        }
        else if (jsbi_1.default.lessThan(thisJsbi, thatJsbi)) {
            return neg ? 1 : -1;
        }
        return 0;
    }
    _initialize(isNegative, coefficient, exponent) {
        this._isNegative = isNegative;
        this._coefficient = coefficient;
        if (Object.is(-0, exponent)) {
            exponent = 0;
        }
        this._exponent = exponent;
    }
    _isNegativeZero() {
        return this.isNegative() && JsbiSupport_1.JsbiSupport.isZero(this._coefficient);
    }
    _compareToParams() {
        let coefficientStr = this.isNegative()
            ? this._coefficient.toString().substring(1)
            : this._coefficient.toString();
        let precision = coefficientStr.length;
        let magnitude = precision + this._exponent;
        if (magnitude <= 0) {
            magnitude -= 1;
        }
        if (JsbiSupport_1.JsbiSupport.isZero(this._coefficient)) {
            magnitude = -Infinity;
        }
        return [coefficientStr, precision, magnitude];
    }
}
exports.Decimal = Decimal;
Decimal.ZERO = new Decimal(0, 0);
Decimal.ONE = new Decimal(1, 0);
//# sourceMappingURL=IonDecimal.js.map