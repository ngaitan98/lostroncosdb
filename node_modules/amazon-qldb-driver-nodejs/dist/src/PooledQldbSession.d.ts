import { QldbSession } from "./QldbSession";
import { QldbSessionImpl } from "./QldbSessionImpl";
import { QldbWriter } from "./QldbWriter";
import { Result } from "./Result";
import { Transaction } from "./Transaction";
import { TransactionExecutor } from "./TransactionExecutor";
/**
 * Represents a pooled session object. See {@linkcode QldbSessionImpl} for more details.
 */
export declare class PooledQldbSession implements QldbSession {
    private _session;
    private _returnSessionToPool;
    private _isClosed;
    /**
     * Creates a PooledQldbSession.
     * @param session The QldbSession object that represents a session to a QLDB ledger.
     * @param returnSessionToPool A lambda that is invoked when {@linkcode PooledQldbSession.close} is called.
     */
    constructor(session: QldbSessionImpl, returnSessionToPool: (Session: QldbSessionImpl) => void);
    /**
     * Close this {@linkcode PooledQldbSession} and return the underlying {@linkcode QldbSession} to the pool.
     */
    close(): void;
    /**
     * Implicitly start a transaction, execute the lambda, and commit the transaction, retrying up to the
     * retry limit if an OCC conflict or retriable exception occurs.
     *
     * @param queryLambda A lambda representing the block of code to be executed within the transaction. This cannot
     *                    have any side effects as it may be invoked multiple times, and the result cannot be trusted
     *                    until the transaction is committed.
     * @param retryIndicator An optional lambda that is invoked when the `querylambda` is about to be retried due to an
     *                       OCC conflict or retriable exception.
     * @returns Promise which fulfills with the return value of the `queryLambda` which could be a {@linkcode Result}
     *          on the result set of a statement within the lambda.
     * @throws {@linkcode SessionClosedError} when this session is closed.
     */
    executeLambda(queryLambda: (transactionExecutor: TransactionExecutor) => any, retryIndicator?: (retryAttempt: number) => void): Promise<any>;
    /**
     * Implicitly start a transaction, execute the statement, and commit the transaction, retrying up to the
     * retry limit if an OCC conflict or retriable exception occurs.
     *
     * @param statement The statement to execute.
     * @param parameters An optional list of QLDB writers containing Ion values to execute.
     * @param retryIndicator An optional lambda that is invoked when the `statement` is about to be retried due to an
     *                       OCC conflict or retriable exception.
     * @returns Promise which fulfills with a Result.
     * @throws {@linkcode SessionClosedError} when this session is closed.
     */
    executeStatement(statement: string, parameters?: QldbWriter[], retryIndicator?: (retryAttempt: number) => void): Promise<Result>;
    /**
     * Return the name of the ledger for the session.
     * @returns Returns the name of the ledger as a string.
     */
    getLedgerName(): string;
    /**
     * Return the session token for this session.
     * @returns Returns the session token as a string.
     */
    getSessionToken(): string;
    /**
     * Lists all tables in the ledger.
     * @returns Promise which fulfills with an array of table names.
     */
    getTableNames(): Promise<string[]>;
    /**
     * Start a transaction using an available database session.
     * @returns Promise which fulfills with a Transaction object.
     * @throws {@linkcode SessionClosedError} when this session is closed.
     */
    startTransaction(): Promise<Transaction>;
    /**
     * Check and throw if this session is closed.
     * @throws {@linkcode SessionClosedError} when this session is closed.
     */
    private _throwIfClosed;
}
