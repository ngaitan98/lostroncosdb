import { Communicator } from "./Communicator";
import { QldbSession } from "./QldbSession";
import { QldbWriter } from "./QldbWriter";
import { Result } from "./Result";
import { Transaction } from "./Transaction";
import { TransactionExecutor } from "./TransactionExecutor";
/**
 * Represents a session to a specific ledger within QLDB, allowing for execution of PartiQL statements and
 * retrieval of the associated results, along with control over transactions for bundling multiple executions.
 *
 * The execute methods provided will automatically retry themselves in the case that an unexpected recoverable error
 * occurs, including OCC conflicts, by starting a brand new transaction and re-executing the statement within the new
 * transaction.
 *
 * There are three methods of execution, ranging from simple to complex; the first two are recommended for inbuilt
 * error handling:
 *  - {@linkcode QldbSessionImpl.executeStatement} allows for a single statement to be executed within a transaction
 *    where the transaction is implicitly created and committed, and any recoverable errors are transparently handled.
 *  - {@linkcode QldbSessionImpl.executeLambda} allow for more complex execution sequences where more than one
 *    execution can occur, as well as other method calls. The transaction is implicitly created and committed, and any
 *    recoverable errors are transparently handled.
 *  - {@linkcode QldbSessionImpl.startTransaction} allows for full control over when the transaction is committed and
 *    leaves the responsibility of OCC conflict handling up to the user. Transactions' methods cannot be automatically
 *    retried, as the state of the transaction is ambiguous in the case of an unexpected error.
 */
export declare class QldbSessionImpl implements QldbSession {
    private _communicator;
    private _retryLimit;
    private _isClosed;
    /**
     * Creates a QldbSessionImpl.
     * @param communicator The Communicator object representing a communication channel with QLDB.
     * @param retryLimit The limit for retries on execute methods when an OCC conflict or retriable exception occurs.
     */
    constructor(communicator: Communicator, retryLimit: number);
    /**
     * Close this session. No-op if already closed.
     */
    close(): void;
    /**
     * Implicitly start a transaction, execute the lambda, and commit the transaction, retrying up to the
     * retry limit if an OCC conflict or retriable exception occurs.
     *
     * @param queryLambda A lambda representing the block of code to be executed within the transaction. This cannot
     *                    have any side effects as it may be invoked multiple times, and the result cannot be trusted
     *                    until the transaction is committed.
     * @param retryIndicator An optional lambda that is invoked when the `querylambda` is about to be retried due to an
     *                       OCC conflict or retriable exception.
     * @returns Promise which fulfills with the return value of the `queryLambda` which could be a {@linkcode Result}
     *          on the result set of a statement within the lambda.
     * @throws {@linkcode SessionClosedError} when this session is closed.
     */
    executeLambda(queryLambda: (transactionExecutor: TransactionExecutor) => any, retryIndicator?: (retryAttempt: number) => void): Promise<any>;
    /**
     * Implicitly start a transaction, execute the statement, and commit the transaction, retrying up to the
     * retry limit if an OCC conflict or retriable exception occurs.
     *
     * @param statement The statement to execute.
     * @param parameters An optional list of QLDB writers containing Ion values to execute.
     * @param retryIndicator An optional lambda that is invoked when the `statement` is about to be retried due to an
     *                       OCC conflict or retriable exception.
     * @returns Promise which fulfills with a Result.
     * @throws {@linkcode SessionClosedError} when this session is closed.
     */
    executeStatement(statement: string, parameters?: QldbWriter[], retryIndicator?: (retryAttempt: number) => void): Promise<Result>;
    /**
     * Return the name of the ledger for the session.
     * @returns Returns the name of the ledger as a string.
     */
    getLedgerName(): string;
    /**
     * Returns the token for this session.
     * @returns Returns the session token as a string.
     */
    getSessionToken(): string;
    /**
     * Lists all tables in the ledger.
     * @returns Promise which fulfills with an array of table names.
     */
    getTableNames(): Promise<string[]>;
    /**
     * Start a transaction using an available database session.
     * @returns Promise which fulfills with a transaction object.
     * @throws {@linkcode SessionClosedError} when this session is closed.
     */
    startTransaction(): Promise<Transaction>;
    /**
     * Determine if the session is alive by sending an abort message. This should only be used when the session is
     * known to not be in use, otherwise the state will be abandoned.
     * @returns Promise which fulfills with true if the abort succeeded, otherwise false.
     */
    _abortOrClose(): Promise<boolean>;
    /**
     * Send an abort request which will not throw on failure.
     * @param transaction The transaction to abort.
     * @returns Promise which fulfills with void.
     */
    private _noThrowAbort;
    /**
     * Sleeps an exponentially increasing amount relative to `attemptNumber`.
     * @param attemptNumber The attempt number for the retry, used for the exponential portion of the sleep.
     * @returns Promise which fulfills with void.
     */
    private _retrySleep;
    /**
     * Helper function for getTableNames.
     * @param resultStream The result from QLDB containing the table names.
     * @returns Promise which fulfills with an array of table names or rejects with a {@linkcode ClientException}
     * when the reader does not contain a struct or if the value within the struct is not of type string.
     */
    private _tableNameHelper;
    /**
     * Check and throw if this session is closed.
     * @throws {@linkcode SessionClosedError} when this session is closed.
     */
    private _throwIfClosed;
}
